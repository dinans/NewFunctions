<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>tabular-functions.pipeline documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Tabular-functions</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to tabular-functions</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tabular-functions</span></div></div></li><li class="depth-2 branch"><a href="tabular-functions.aggregations.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aggregations</span></div></a></li><li class="depth-2 branch"><a href="tabular-functions.datatypes.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datatypes</span></div></a></li><li class="depth-2 branch current"><a href="tabular-functions.pipeline.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pipeline</span></div></a></li><li class="depth-2"><a href="tabular-functions.stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stats</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="tabular-functions.pipeline.html#var-add-row"><div class="inner"><span>add-row</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-cast"><div class="inner"><span>cast</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-group-rows"><div class="inner"><span>group-rows</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-join-dataset"><div class="inner"><span>join-dataset</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-merge-columns"><div class="inner"><span>merge-columns</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-remove-columns"><div class="inner"><span>remove-columns</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-remove-duplicates"><div class="inner"><span>remove-duplicates</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-shift-column"><div class="inner"><span>shift-column</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-shift-row"><div class="inner"><span>shift-row</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-sort-dataset"><div class="inner"><span>sort-dataset</span></div></a></li><li class="depth-1"><a href="tabular-functions.pipeline.html#var-split-column"><div class="inner"><span>split-column</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">tabular-functions.pipeline</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-add-row"><h3>add-row</h3><div class="usage"><code>(add-row dataset [&amp; values])</code><code>(add-row dataset position [&amp; values])</code></div><div class="doc"><pre class="plaintext">Inserts new row into a dataset. Two options are available:
1. Takes a dataset and vector containing field values and appends new row to the end of a dataset, e.g.
        
        Given original dataset
        
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 1   | 2   | 3   |
            | 4   | 5   | 6   |
            | 7   | 8   | 9   |

        function returns the following result:
     
            `(add-row dataset [10 11 12]) ; =&gt;`

    
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 1   | 2   | 3   |
            | 4   | 5   | 6   |
            | 7   | 8   | 9   |
            | 10  | 11  | 12  | 

2. Takes a dataset, row index and vector containing field values and inserts new row at the specified position. 
   If position index is negative or greater then total number of rows in a dataset, the new row will be apended to a dataset.

        Given original dataset
        
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 1   | 2   | 3   |
            | 4   | 5   | 6   |
            | 7   | 8   | 9   |

        function returns the following result:
     
            `(add-row dataset 1 [10 11 12]) ; =&gt;`

    
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 1   | 2   | 3   |
            | 10  | 11  | 12  | 
            | 4   | 5   | 6   |
            | 7   | 8   | 9   |
            
            
            `(add-row dataset -2 [10 11 12]) ; =&gt;`

    
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 10  | 11  | 12  | 
            | 1   | 2   | 3   |
            | 4   | 5   | 6   |
            | 7   | 8   | 9   |


  For both options if number of parameters denoting field values is less than current number of columns in a dataset, 
  lacking values for columns will remain empty. If number of parameters denoting field values is greater than number 
  of columns in a dataset, rest of the values will be discarded.</pre></div></div><div class="public anchor" id="var-cast"><h3>cast</h3><div class="usage"><code>(cast dataset variable value f)</code></div><div class="doc"><pre class="plaintext">Given a dataset, name of variable-column that should be used to generate new columns(raise from row values to column names),
name of a value-column and aggregation operation reshapes a dataset. Function performs  the opposite actions  compared to the Grafter
`melt` function. All columns except of value-column act as unique id, if duplicates are found, function will throw an error. Example:
          
             Given original dataset:

                  |      :company-name |             :position |  :total-employed |
                  |--------------------+-----------------------+------------------|
                  |              Cisco | Jr.Software developer |               22 |
                  |              Cisco | Sr.Software developer |               10 |
                  |              Cisco |                Intern |                2 |
                  | Oracle corporation |        Assist.manager |                2 |
                  | Oracle corporation | Sr.Software developer |               38 |
                  |                IBM |        Assist.manager |                2 |
                  |                IBM | Jr.Software developer |                8 |
                  |              Cisco |        Assist.manager |                3 |
                  |                IBM | Sr.Software developer |                5 |
                  |                IBM |                Intern |                4 |


             function returns the following result:

             `(raise :position :total-employed) ;  =&gt;`


                  |      :company-name | :Jr.Software developer | :Sr.Software developer | :Intern | :Assist.manager |
                  |--------------------+------------------------+------------------------+---------+-----------------|
                  |              Cisco |                     22 |                     10 |       2 |               3 |  
                  |                IBM |                      8 |                      5 |       4 |               2 |
                  | Oracle corporation |                        |                     38 |         |               2 |

          </pre></div></div><div class="public anchor" id="var-group-rows"><h3>group-rows</h3><div class="usage"><code>(group-rows dataset colnames colnames-functions)</code></div><div class="doc"><pre class="plaintext">Given a dataset, vector of column names and set of maps of form  {colname function-or-separator-name} and creates a new 
dataset containg rows grouped by colnames from vector and the result of applying functions to correspondent column values. If function name is not recognized as a common aggregation function, argument will be used as a separator for merged values 
Each function in a map should take sequence of values as  a parameter and return a single value. 
             
               For most common aggregations there exists a set of pre-defined functions:
               - MIN
               - MAX
               - SUM
               - AVG
               - COUNT
              
      
      Example1. Given original dataset:
                 


               | :firstname | :lastname | :order_num | :total_items | :total_cost |
               |------------+-----------+------------+--------------+-------------|
               |      Alice |     Smith |       1111 |            5 |         150 |
               |        Bob |   Johnson |        857 |            7 |          70 |
               |      Alice |     Smith |       1112 |           30 |         340 |
               |      Alice |  Williams |        505 |            1 |         170 |
               |        Bob |   Johnson |        858 |            3 |         370 |
               |       Mary |  Williams |       1543 |            1 |          15 |

 

        function returns the following result:

        `(group-rows dataset [:firstname :lastname] #{ {:total_items &quot;SUM&quot;}   ; total number of items person ordered
                                                  #_=&gt; {:total_cost &quot;AVG&quot;}    ; average total cost per one order
                                                  #_=&gt; {:order_num &quot;COUNT&quot;}   ; number of orders person made
                                                  #_=&gt; {:total_cost &quot;MAX&quot;}})  ; maximum total_cost per one order =&gt;`

               | :firstname | :lastname | :order_num_COUNT | :total_cost_AVG | :total_items_SUM | :total_cost_MAX |
               |------------+-----------+------------------+-----------------+------------------+-----------------|
               |      Alice |     Smith |                2 |             245 |               35 |             340 |
               |        Bob |   Johnson |                2 |             220 |               10 |             370 |
               |      Alice |  Williams |                1 |             170 |                1 |             170 |
               |       Mary |  Williams |                1 |              15 |                1 |              15 |

                  
                      
      Example2. Given original dataset:
                  
                  | :name |    :phone-number |  
                  |-------+------------------|
                  | Alice |        123-45-67 |
                  |   Bob |        777-88-99 |
                  | Alice |        111-11-11 |

 

      function returns the following result:

        `(group-rows dataset [:name] #{{:phone-nuber &quot;, &quot;}}) ;  =&gt;`

                  | :name |        :phone-number |  
                  |-------+----------------------|
                  | Alice | 123-45-67, 111-11-11 |
                  |   Bob |            777-88-99 |
               </pre></div></div><div class="public anchor" id="var-join-dataset"><h3>join-dataset</h3><div class="usage"><code>(join-dataset dataset filename concat-type)</code><code>(join-dataset dataset filename fkey id value)</code></div><div class="doc"><pre class="plaintext">Joins two datasets together. Two options are available:
                 
1. Takes a dataset, filename and type of concatenation (either :v to concatenate datasets vertically -- append data from file 
to the right side of given dataset or :h to concatenate datasets horizontally -- append data from file to the bottom of 
given dataset). 

Throws an error if number of columns/rows is not appropriate
                 
Examples.

      Given original dataset:
                  
                  | :name |    :age |  :gender |
                  |-------+---------+----------|
                  | Alice |      18 |   female |
                  |   Bob |      30 |     male |
      
      file &apos;left-part.csv&apos; with content:
                 
                 email,country
                 alice@example.com,Norway
                 bob@example.com,Norway
      

        function returns the following result:

        `(join-dataset &quot;left-part.csv&quot; :v) ;  =&gt;`

                  | :name |    :age |  :gender |            :email | country | 
                  |-------+---------+----------+-------------------+---------|
                  | Alice |      18 |   female | alice@example.com |  Norway |
                  |   Bob |      30 |     male |   bob@example.com |  Norway |

     
      Given the same original dataset and file &apos;other-persons.csv&apos; with content:
                 
                 name,age,gender
                 John,38,male
                 Mary,27,female

        function returns the following result:

        `(join-dataset &quot;other-persons.csv&quot; :h) ;  =&gt;`
                  
                  | :name |    :age |  :gender |
                  |-------+---------+----------|
                  | Alice |      18 |   female |
                  |   Bob |      30 |     male |
                  |  John |      38 |     male |
                  |  Mary |      27 |   female |
      
            
2. Takes a dataset, filename, column that acts as foreign key in original dataset and columns for id and value in file. 
Builds a lookup table from file and maps values in original dataset appropriately.
                 
      Given original dataset:
                  
                  | :name |    :age |  :position |
                  |-------+---------+------------|
                  | Alice |      18 |         25 |
                  |   Bob |      30 |          7 |
      
      file &apos;position-codes.csv&apos; with content:
                 
                 code,description
                 1,manager
                 7,engineer
                 8,senior engineer
                 25,accountant
      

        function returns the following result:

        `(join-dataset &quot;position-codes.csv&quot; :position &quot;code&quot; &quot;description&quot;) ;  =&gt;`


                  | :name |    :age |  :position |
                  |-------+---------+------------|
                  | Alice |      18 | accountant |
                  |   Bob |      30 |   engineer |
                 </pre></div></div><div class="public anchor" id="var-merge-columns"><h3>merge-columns</h3><div class="usage"><code>(merge-columns dataset columns separator)</code><code>(merge-columns dataset columns separator newname)</code></div><div class="doc"><pre class="plaintext">Merges several columns in one using specified separator between columns. Two options are available:
1. Takes a dataset, vector of columns and separator and merges columns together. Column containing the result of the merge 
gets the same name as the first column in the list of arguments:
                  
        Given original dataset:
                  
                  | :name |   :city | :country |            :email |
                  |-------+---------+----------+-------------------|
                  | Alice |    Oslo |   Norway | alice@example.com |
                  |   Bob | Drammen |   Norway |   bob@example.com |

 

        function returns the following result:

        `(merge-columns [:city :country] &quot;, &quot;) ;  =&gt;`

                  | :name |           :city |            :email |
                  |-------+-----------------+-------------------|
                  | Alice |    Oslo, Norway | alice@example.com |
                  |   Bob | Drammen, Norway |   bob@example.com |

                  
2. Takes a dataset, vector of columns, separator and new column name and merges columns together.

        Given original dataset:

                  | :name |   :city | :country |            :email |
                  |-------+---------+----------+-------------------|
                  | Alice |    Oslo |   Norway | alice@example.com |
                  |   Bob | Drammen |   Norway |   bob@example.com |

 

        function returns the following result:

        `(merge-columns [:city :country] &quot;, &quot; :place) ;  =&gt;`

                  | :name |          :place |            :email |
                  |-------+-----------------+-------------------|
                  | Alice |    Oslo, Norway | alice@example.com |
                  |   Bob | Drammen, Norway |   bob@example.com |

                  </pre></div></div><div class="public anchor" id="var-remove-columns"><h3>remove-columns</h3><div class="usage"><code>(remove-columns dataset cols)</code><code>(remove-columns dataset indexFrom indexTo)</code></div><div class="doc"><pre class="plaintext">Removes columns from a dataset. Two options are available:
1. Takes a dataset and vector of column names and creates a new dataset containing all columns except of those that were specified.

       
          Given original dataset
                
                   | :col1 | :col2 | :col3 | :col4 |
                   |-------+-------+-------+-------|
                   |     1 |     2 |     3 |     4 |
                   |     5 |     6 |     7 |     8 |
                   |     9 |    10 |    11 |    12 |


        function returns the following result:
          
        `(remove-columns [:col1 :col4]) ; =&gt;`

                   | :col2 | :col3 |
                   |-------+-------|
                   |     2 |     3 |
                   |     6 |     7 |
                   |    10 |    11 |


2. Takes a dataset and two indices and creates a new dataset containing all columns execept of columns having indices within 
   the specified interval (including both points)                     

        Given original dataset

                   | a | b | c | d | e | f |
                   |---+---+---+---+---+---|
                   | 0 | 0 | 0 | 0 | 0 | 0 |
                   | 1 | 1 | 1 | 1 | 1 | 1 |
                   | 2 | 2 | 2 | 2 | 2 | 2 |


        function returns the following result:

        `(remove-columns 2 4) ; Remove columns having indices within the interval [2, 4] =&gt;`

                   | a | b | f |
                   |---+---+---|
                   | 0 | 0 | 0 |
                   | 1 | 1 | 1 |
                   | 2 | 2 | 2 |

        </pre></div></div><div class="public anchor" id="var-remove-duplicates"><h3>remove-duplicates</h3><div class="usage"><code>(remove-duplicates dataset)</code><code>(remove-duplicates dataset colnames)</code></div><div class="doc"><pre class="plaintext">Removes duplicates from a dataset. Two options are available:

1. Given a dataset sorts it and looks for rows having the same values across all columns and leaves only one instance 
from each set of such rows, other rows(duplicates) will be removed from a dataset.
                      
      Given original dataset:
                  
                  | :name |    :age |  :gender |
                  |-------+---------+----------|
                  | Alice |      18 |   female |
                  |   Bob |      30 |     male |
                  | Alice |      28 |   female |
                  | Alice |      18 |   female |
                  |   Bob |      32 |     male |

 

        function returns the following result:

        `(remove-duplicates dataset) ;  =&gt;`

                  | :name |    :age |  :gender |
                  |-------+---------+----------|
                  | Alice |      18 |   female |
                  | Alice |      28 |   female |
                  |   Bob |      30 |     male |
                  |   Bob |      32 |     male |
                      
2. Given a dataset and a column(sequence of columns) looks for rows having the same values in the specified field(s) and leaves 
only the first encountered row in this sequence. Dataset should be sorted in desired order before function is called
                  
                      
      Given original dataset:
                  
                  | :name |    :age |  :gender |
                  |-------+---------+----------|
                  | Alice |      18 |   female |
                  |   Bob |      30 |     male |
                  | Alice |      28 |   female |
                  |   Bob |      32 |     male |

 

      function returns the following result:

        `(-&gt; (sort-dataset dataset  [:name :age] :alpha :desc) (remove-duplicates [:name :gender]) ;  Dataset is first sorted in a such way 
                                                                                            that the records about the same person 
                                                                                            are given in descending order by age =&gt;`

                  | :name |    :age |  :gender |
                  |-------+---------+----------|
                  | Alice |      28 |   female |
                  |   Bob |      32 |     male |


                      </pre></div></div><div class="public anchor" id="var-shift-column"><h3>shift-column</h3><div class="usage"><code>(shift-column dataset column)</code><code>(shift-column dataset column position-to)</code></div><div class="doc"><pre class="plaintext">Changes column&apos;s position inside a dataset. Two options are available:
1. Takes a dataset and column name/index and moves this column to the last position, data columns with indices greater than 
specified index will be moved one position left e.g.
        
        Given original dataset
              
              | :a | :b | :c | :d |
              |----+----+----+----|
              |  1 |  2 |  3 |  a |
              |  4 |  5 |  6 |  b |
              |  7 |  8 |  9 |  c |


        function returns the following result:
          
        `(shift-column :b) ; =&gt;`
        
        which is equivalent to
        `(shift-column 1) ; =&gt;`

              | :a | :c | :d | :b |
              |----+----+----+----|
              |  1 |  3 |  a |  2 |
              |  4 |  6 |  b |  5 |
              |  7 |  9 |  c |  8 |


2. Takes a dataset, column name/index and index where this column should be moved, moves given column to the specified index.  
Other columns will be shifted appropriately.
        
        Given original dataset
              
              | :a | :b | :c | :d |
              |----+----+----+----|
              |  1 |  2 |  3 |  a |
              |  4 |  5 |  6 |  b |
              |  7 |  8 |  9 |  c |


        function returns the following result:
          
        `(shift-column :c 0) ; =&gt;`
        
        which is equivalent to
        `(shift-column 2 0) ; =&gt;`
              
              
              | :c | :a | :b | :d |
              |----+----+----+----|
              |  3 |  1 |  2 |  a |
              |  6 |  4 |  5 |  b |
              |  9 |  7 |  8 |  c |</pre></div></div><div class="public anchor" id="var-shift-row"><h3>shift-row</h3><div class="usage"><code>(shift-row dataset position-from)</code><code>(shift-row dataset position-from position-to)</code></div><div class="doc"><pre class="plaintext">Changes row&apos;s position inside a dataset. Two options are available:
1. Takes a dataset and row index and moves this row to the end of a dataset, data rows with indices greater than specified index 
   will be moved one position up e.g.
        
        Given original dataset
        
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 1   | 2   | 3   |
            | 4   | 5   | 6   |
            | 7   | 8   | 9   |
            | 10  | 11  | 12  | 

        function returns the following result:
     
            `(shift-row dataset 1) ; =&gt;`

    
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 1   | 2   | 3   |
            | 7   | 8   | 9   |
            | 10  | 11  | 12  | 
            | 4   | 5   | 6   |

2. Takes a dataset and two row indices and moves row from index #1 to index #2.  
   Other rows will be shifted appropriately.

        Given original dataset
        
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 1   | 2   | 3   |
            | 4   | 5   | 6   |
            | 7   | 8   | 9   |
            | 10  | 11  | 12  | 

        function returns the following result:
     
            `(shift-row dataset 1 3) ; =&gt;`

    
            |:col1|:col2|:col3|
            |-----|-----|-----|
            | 1   | 2   | 3   |
            | 7   | 8   | 9   |
            | 10  | 11  | 12  | 
            | 4   | 5   | 6   |
              
 </pre></div></div><div class="public anchor" id="var-sort-dataset"><h3>sort-dataset</h3><div class="usage"><code>(sort-dataset dataset colnames-sorttypes)</code></div><div class="doc"><pre class="plaintext">Sorts dataset by given column names in given order. Column names and types of sorting are given in a vector. 
Sorting priority is defined by order of column name -- sorting type pair. Sorting by multiple columns works as follows: 
if several rows have equal columns(first in the vector of given columns) according to the given comparator type, these rows 
will be sorted by second column and second comparator, if both first and second are equal, sorting will be performed by the third column 
and third comparator etc.                 

Type of comparator used for sorting is defined as one of following:

                 - :ascalpha, :descalpha for alphabetical sorting (in ascending and descending order correspondingly);
                 - :ascnum, :descnum for numerical sorting;
                 - :asclen, :desclen for sorting by field length;
                 - :ascdate, :descdate for sorting dates

  Examples:
                 
           Given original dataset
 
                 |  :a |                 :b | :c |         :d |
                 |-----+--------------------+----+------------|
                 |   2 |             string |  1 | 01.01.2015 |
                 | 111 |             string |  3 | 03.11.2015 |
                 |  44 |      longer string |  9 | 03.03.2013 |
                 |   3 | the longest string |  6 | 25.12.2015 |


           calling function with different parameters results in following datasets:

              `(sort-dataset dataset [{:a :ascalpha}]) ; sort by column :a in ascending alphabetical order =&gt;`
                 

                 |  :a |                 :b | :c |         :d |
                 |-----+--------------------+----+------------|
                 | 111 |             string |  3 | 03.11.2015 |
                 |   2 |             string |  1 | 01.01.2015 |
                 |   3 | the longest string |  6 | 25.12.2015 |
                 |  44 |      longer string |  9 | 03.03.2013 |



             `(sort-dataset dataset [{:a :descalpha}]) ; sort by column :a in descending alphabetical order =&gt;`

                 |  :a |                 :b | :c |         :d |
                 |-----+--------------------+----+------------|
                 | 111 |             string |  3 | 03.11.2015 |
                 |   2 |             string |  1 | 01.01.2015 |
                 |   3 | the longest string |  6 | 25.12.2015 |
                 |  44 |      longer string |  9 | 03.03.2013 |


             `(sort-dataset dataset [{:a :ascnum}]) ; sort by column :a in ascending numerical order =&gt;`

                 |  :a |                 :b | :c |         :d |
                 |-----+--------------------+----+------------|
                 |   2 |             string |  1 | 01.01.2015 |
                 |   3 | the longest string |  6 | 25.12.2015 |
                 |  44 |      longer string |  9 | 03.03.2013 |
                 | 111 |             string |  3 | 03.11.2015 |


             `(sort-dataset dataset [{:b :asclen}]) ; sort by column :b in ascending order by field length =&gt;`


                 |  :a |                 :b | :c |         :d |
                 |-----+--------------------+----+------------|
                 |   2 |             string |  1 | 01.01.2015 |
                 |   3 | the longest string |  6 | 25.12.2015 |
                 |  44 |      longer string |  9 | 03.03.2013 |
                 | 111 |             string |  3 | 03.11.2015 |
                 
                 
             `(sort-dataset dataset [{:d :ascdate}]) ; sort by column :d in ascending order by date =&gt;`


                 |  :a |                 :b | :c |         :d |
                 |-----+--------------------+----+------------|
                 |  44 |      longer string |  9 | 03.03.2013 |
                 |   2 |             string |  1 | 01.01.2015 |
                 | 111 |             string |  3 | 03.11.2015 |
                 |   3 | the longest string |  6 | 25.12.2015 |


             `(sort-dataset dataset [{:b asclen} {:a :asclen}]) ; sort by column :b in ascending order by field length, for equal values arrange by column :a in ascending order by length =&gt;`


                 |  :a |                 :b | :c |         :d |
                 |-----+--------------------+----+------------|
                 |   2 |             string |  1 | 01.01.2015 |
                 | 111 |             string |  3 | 03.11.2015 |
                 |  44 |      longer string |  9 | 03.03.2013 |
                 |   3 | the longest string |  6 | 25.12.2015 |



             `(sort-dataset dataset [{:a asclen} {:b :asclen}]) ; sort by column :a in ascending order by field length, for equal values arrange by column :b in ascending order by length =&gt;`


                 |  :a |                 :b | :c |         :d |
                 |-----+--------------------+----+------------|
                 |   2 |             string |  1 | 01.01.2015 |
                 |   3 | the longest string |  6 | 25.12.2015 |
                 |  44 |      longer string |  9 | 03.03.2013 |
                 | 111 |             string |  3 | 03.11.2015 |
                 
                 Note: sorting by date requires dates in column to be in &apos;dd.mm.yyyy&apos; format( for conversion date-literal function may be used)
                 </pre></div></div><div class="public anchor" id="var-split-column"><h3>split-column</h3><div class="usage"><code>(split-column dataset colname separator)</code></div><div class="doc"><pre class="plaintext">Given a dataset, column name and separator splits specified column into multiple by separator. New columns get 
names of a form [original-column-name]_splitted_0, [original-column-name]_splitted_1, ...

                  
         Given original dataset:

                   | :name |                       :address |            :email |
                   |-------+--------------------------------+-------------------|
                   | Alice | New York, Harrison Street, 507 | alice@example.com |
                   |   Bob |      Richmond, Main Street, 17 |   bob@example.com |
                   |  Mary | NY, Harrison Street, 29, H0512 |  mary@example.com |


  

         function returns the following result:

         `(split-column :address #&quot;, &quot;) ;  =&gt;`


                  | :name | :address_splitted_0 | :address_splitted_1 | :address_splitted_2 | :address_splitted_3 |            :email |
                  |-------+---------------------+---------------------+---------------------+---------------------+-------------------|
                  | Alice |            New York |     Harrison Street |                 507 |                     | alice@example.com |
                  |   Bob |            Richmond |         Main Street |                  17 |                     |   bob@example.com |
                  |  Mary |                  NY |     Harrison Street |                  29 |               H0512 |  mary@example.com |

</pre></div></div></div></body></html>